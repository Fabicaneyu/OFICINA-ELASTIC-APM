"use strict";

exports.__esModule = true;
exports.patchXMLHttpRequest = patchXMLHttpRequest;

var _patchUtils = require("./patch-utils");

var _utils = require("../utils");

var _constants = require("../constants");

var XHR_TASK = (0, _patchUtils.apmSymbol)('xhrTask');
var XHR_LISTENER = (0, _patchUtils.apmSymbol)('xhrListener');
var XHR_SCHEDULED = (0, _patchUtils.apmSymbol)('xhrScheduled');

function patchXMLHttpRequest(callback) {
  var XMLHttpRequestPrototype = XMLHttpRequest.prototype;
  var oriAddListener = XMLHttpRequestPrototype[_constants.ADD_EVENT_LISTENER_STR];
  var oriRemoveListener = XMLHttpRequestPrototype[_constants.REMOVE_EVENT_LISTENER_STR];

  if (!oriAddListener) {
    var XMLHttpRequestEventTarget = window['XMLHttpRequestEventTarget'];

    if (XMLHttpRequestEventTarget) {
      var XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;
      oriAddListener = XMLHttpRequestEventTargetPrototype[_constants.ADD_EVENT_LISTENER_STR];
      oriRemoveListener = XMLHttpRequestEventTargetPrototype[_constants.REMOVE_EVENT_LISTENER_STR];
    }
  }

  var READY_STATE_CHANGE = 'readystatechange';
  var LOAD = 'load';

  function invokeTask(task) {
    task.state = _constants.INVOKE;
    callback(_constants.INVOKE, task);
  }

  function scheduleTask(task) {
    XMLHttpRequest[XHR_SCHEDULED] = false;
    task.state = _constants.SCHEDULE;
    callback(_constants.SCHEDULE, task);
    var _task$data = task.data,
        aborted = _task$data.aborted,
        target = _task$data.target;

    if (!oriAddListener) {
      oriAddListener = target[_constants.ADD_EVENT_LISTENER_STR];
      oriRemoveListener = target[_constants.REMOVE_EVENT_LISTENER_STR];
    }

    var listener = target[XHR_LISTENER];

    if (listener) {
      oriRemoveListener.call(target, READY_STATE_CHANGE, listener);
      oriRemoveListener.call(target, LOAD, listener);
    }

    var earlierEvent;

    var newListener = target[XHR_LISTENER] = function (_ref) {
      var type = _ref.type;

      if (earlierEvent) {
        if (earlierEvent != type) {
          (0, _utils.scheduleMacroTask)(function () {
            if (task.state !== _constants.INVOKE) {
              invokeTask(task);
            }
          });
        }
      } else {
        if (target.readyState === target.DONE) {
          if (!aborted && XMLHttpRequest[XHR_SCHEDULED] && task.state === _constants.SCHEDULE) {
            earlierEvent = type;
          }
        }
      }
    };

    oriAddListener.call(target, READY_STATE_CHANGE, newListener);
    oriAddListener.call(target, LOAD, newListener);
    var storedTask = target[XHR_TASK];

    if (!storedTask) {
      target[XHR_TASK] = task;
    }
  }

  function clearTask(task) {
    task.state = _constants.CLEAR;
    callback(_constants.CLEAR, task);
    var data = task.data;
    data.aborted = true;
  }

  var openNative = (0, _patchUtils.patchMethod)(XMLHttpRequestPrototype, 'open', function () {
    return function (self, args) {
      if (!self[_patchUtils.XHR_IGNORE]) {
        self[_patchUtils.XHR_METHOD] = args[0];
        self[_patchUtils.XHR_URL] = args[1];
        self[_patchUtils.XHR_SYNC] = args[2] === false;
      }

      return openNative.apply(self, args);
    };
  });
  var sendNative = (0, _patchUtils.patchMethod)(XMLHttpRequestPrototype, 'send', function () {
    return function (self, args) {
      if (self[_patchUtils.XHR_IGNORE]) {
        return sendNative.apply(self, args);
      }

      var task = {
        source: _constants.XMLHTTPREQUEST,
        state: '',
        type: 'macroTask',
        data: {
          target: self,
          method: self[_patchUtils.XHR_METHOD],
          sync: self[_patchUtils.XHR_SYNC],
          url: self[_patchUtils.XHR_URL],
          aborted: false
        }
      };
      scheduleTask(task);
      var result = sendNative.apply(self, args);
      XMLHttpRequest[XHR_SCHEDULED] = true;

      if (self[_patchUtils.XHR_SYNC]) {
        invokeTask(task);
      }

      return result;
    };
  });
  var abortNative = (0, _patchUtils.patchMethod)(XMLHttpRequestPrototype, 'abort', function () {
    return function (self, args) {
      if (!self[_patchUtils.XHR_IGNORE]) {
        var task = self[XHR_TASK];

        if (task && typeof task.type === 'string') {
          if (task.data && task.data.aborted) {
            return;
          }

          clearTask(task);
        }
      }

      return abortNative.apply(self, args);
    };
  });
}