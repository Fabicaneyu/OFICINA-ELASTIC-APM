import { checkSameOrigin, isDtHeaderValid, parseDtHeaderValue, stripQueryStringFromUrl, getDtHeaderValue } from '../common/utils';
import Url from '../common/url';
import { patchEventHandler } from '../common/patching';
import { globalState } from '../common/patching/patch-utils';
import { SCHEDULE, INVOKE, TRANSACTION_END, AFTER_EVENT, FETCH, HISTORY, XMLHTTPREQUEST, HTTP_REQUEST_TYPE, BROWSER_RESPONSIVENESS_INTERVAL, BROWSER_RESPONSIVENESS_BUFFER, SIMILAR_SPAN_TO_TRANSACTION_RATIO } from '../common/constants';
import { truncateModel, SPAN_MODEL, TRANSACTION_MODEL } from '../common/truncate';
import { __DEV__ } from '../env';

var PerformanceMonitoring = function () {
  function PerformanceMonitoring(apmServer, configService, loggingService, transactionService) {
    this._apmServer = apmServer;
    this._configService = configService;
    this._logginService = loggingService;
    this._transactionService = transactionService;
  }

  var _proto = PerformanceMonitoring.prototype;

  _proto.init = function init(flags) {
    var _this = this;

    if (flags === void 0) {
      flags = {};
    }

    this._configService.events.observe(TRANSACTION_END + AFTER_EVENT, function (tr) {
      var payload = _this.createTransactionPayload(tr);

      if (payload) {
        _this._apmServer.addTransaction(payload);
      }
    });

    if (flags[HISTORY]) {
      patchEventHandler.observe(HISTORY, this.getHistorySub());
    }

    if (flags[XMLHTTPREQUEST]) {
      patchEventHandler.observe(XMLHTTPREQUEST, this.getXHRSub());
    }

    if (flags[FETCH]) {
      patchEventHandler.observe(FETCH, this.getFetchSub());
    }
  };

  _proto.getHistorySub = function getHistorySub() {
    var transactionService = this._transactionService;
    return function (event, task) {
      if (task.source === HISTORY && event === INVOKE) {
        transactionService.startTransaction(task.data.title, 'route-change', {
          managed: true,
          canReuse: true
        });
      }
    };
  };

  _proto.getXHRSub = function getXHRSub() {
    var _this2 = this;

    return function (event, task) {
      if (task.source === XMLHTTPREQUEST && !globalState.fetchInProgress) {
        _this2.processAPICalls(event, task);
      }
    };
  };

  _proto.getFetchSub = function getFetchSub() {
    var _this3 = this;

    return function (event, task) {
      if (task.source === FETCH) {
        _this3.processAPICalls(event, task);
      }
    };
  };

  _proto.processAPICalls = function processAPICalls(event, task) {
    var configService = this._configService;
    var transactionService = this._transactionService;

    if (event === SCHEDULE && task.data) {
      var data = task.data;
      var requestUrl = new Url(data.url);
      var spanName = data.method + ' ' + (requestUrl.relative ? requestUrl.path : stripQueryStringFromUrl(requestUrl.href));

      if (!transactionService.getCurrentTransaction()) {
        transactionService.startTransaction(spanName, HTTP_REQUEST_TYPE, {
          managed: true
        });
      }

      var span = transactionService.startSpan(spanName, 'external.http');
      var taskId = transactionService.addTask();

      if (!span) {
        return;
      }

      var isDtEnabled = configService.get('distributedTracing');
      var dtOrigins = configService.get('distributedTracingOrigins');
      var currentUrl = new Url(window.location.href);
      var isSameOrigin = checkSameOrigin(requestUrl.origin, currentUrl.origin) || checkSameOrigin(requestUrl.origin, dtOrigins);
      var target = data.target;

      if (isDtEnabled && isSameOrigin && target) {
        this.injectDtHeader(span, target);
      }

      span.sync = data.sync;
      data.span = span;
      task.id = taskId;
    } else if (event === INVOKE) {
      if (task.data && task.data.span) {
        task.data.span.end(null, task.data);
      }

      if (task.id) {
        transactionService.removeTask(task.id);
      }
    }
  };

  _proto.injectDtHeader = function injectDtHeader(span, target) {
    var configService = this._configService;
    var headerName = configService.get('distributedTracingHeaderName');
    var headerValue = getDtHeaderValue(span);
    var isHeaderValid = isDtHeaderValid(headerValue);

    if (headerName && headerValue && isHeaderValid) {
      if (typeof target.setRequestHeader === 'function') {
        target.setRequestHeader(headerName, headerValue);
      } else if (target.headers && typeof target.headers.append === 'function') {
        target.headers.append(headerName, headerValue);
      } else {
        target[headerName] = headerValue;
      }
    }
  };

  _proto.extractDtHeader = function extractDtHeader(target) {
    var configService = this._configService;
    var headerName = configService.get('distributedTracingHeaderName');

    if (target) {
      return parseDtHeaderValue(target[headerName]);
    }
  };

  _proto.filterTransaction = function filterTransaction(tr) {
    var transactionDurationThreshold = this._configService.get('transactionDurationThreshold');

    var duration = tr.duration();

    if (!duration) {
      if (__DEV__) {
        var message = "transaction(" + tr.id + ", " + tr.name + ") was discarded! ";

        if (duration === 0) {
          message += "Transaction duration is 0";
        } else {
          message += "Transaction wasn't ended";
        }

        this._logginService.debug(message);
      }

      return false;
    }

    if (duration > transactionDurationThreshold) {
      if (__DEV__) {
        this._logginService.debug("transaction(" + tr.id + ", " + tr.name + ") was discarded! Transaction duration (" + duration + ") is greater than the transactionDurationThreshold configuration (" + transactionDurationThreshold + ")");
      }

      return false;
    }

    if (!tr.sampled) {
      tr.resetSpans();
    }

    if (tr.options.checkBrowserResponsiveness) {
      var wasBrowserResponsive = this.checkBrowserResponsiveness(tr, BROWSER_RESPONSIVENESS_INTERVAL, BROWSER_RESPONSIVENESS_BUFFER);

      if (!wasBrowserResponsive) {
        if (__DEV__) {
          this._logginService.debug("transaction(" + tr.id + ", " + tr.name + ") was discarded! Browser was not responsive enough during the transaction.", ' duration:', duration, ' browserResponsivenessCounter:', tr.browserResponsivenessCounter);
        }

        return false;
      }
    }

    return true;
  };

  _proto.prepareTransaction = function prepareTransaction(transaction) {
    transaction.spans.sort(function (spanA, spanB) {
      return spanA._start - spanB._start;
    });

    if (this._configService.get('groupSimilarSpans')) {
      transaction.spans = this.groupSmallContinuouslySimilarSpans(transaction, SIMILAR_SPAN_TO_TRANSACTION_RATIO);
    }

    transaction.spans = transaction.spans.filter(function (span) {
      return span.duration() > 0 && span._start >= transaction._start && span._end <= transaction._end;
    });
  };

  _proto.createTransactionDataModel = function createTransactionDataModel(transaction) {
    var transactionStart = transaction._start;
    var spans = transaction.spans.map(function (span) {
      var spanData = {
        id: span.id,
        transaction_id: transaction.id,
        parent_id: span.parentId || transaction.id,
        trace_id: transaction.traceId,
        name: span.name,
        type: span.type,
        subType: span.subType,
        action: span.action,
        sync: span.sync,
        start: span._start - transactionStart,
        duration: span.duration(),
        context: span.context
      };
      return truncateModel(SPAN_MODEL, spanData);
    });
    var transactionData = {
      id: transaction.id,
      trace_id: transaction.traceId,
      name: transaction.name,
      type: transaction.type,
      duration: transaction.duration(),
      spans: spans,
      context: transaction.context,
      marks: transaction.marks,
      breakdown: transaction.breakdownTimings,
      span_count: {
        started: spans.length
      },
      sampled: transaction.sampled
    };
    return truncateModel(TRANSACTION_MODEL, transactionData);
  };

  _proto.createTransactionPayload = function createTransactionPayload(transaction) {
    this.prepareTransaction(transaction);
    var filtered = this.filterTransaction(transaction);

    if (filtered) {
      return this.createTransactionDataModel(transaction);
    }
  };

  _proto.convertTransactionsToServerModel = function convertTransactionsToServerModel(transactions) {
    var _this4 = this;

    return transactions.map(function (tr) {
      return _this4.createTransactionDataModel(tr);
    });
  };

  _proto.groupSmallContinuouslySimilarSpans = function groupSmallContinuouslySimilarSpans(transaction, threshold) {
    var transDuration = transaction.duration();
    var spans = [];
    var lastCount = 1;
    transaction.spans.forEach(function (span, index) {
      if (spans.length === 0) {
        spans.push(span);
      } else {
        var lastSpan = spans[spans.length - 1];
        var isContinuouslySimilar = lastSpan.type === span.type && lastSpan.subType === span.subType && lastSpan.action === span.action && lastSpan.name === span.name && span.duration() / transDuration < threshold && (span._start - lastSpan._end) / transDuration < threshold;
        var isLastSpan = transaction.spans.length === index + 1;

        if (isContinuouslySimilar) {
          lastCount++;
          lastSpan._end = span._end;
        }

        if (lastCount > 1 && (!isContinuouslySimilar || isLastSpan)) {
          lastSpan.name = lastCount + 'x ' + lastSpan.name;
          lastCount = 1;
        }

        if (!isContinuouslySimilar) {
          spans.push(span);
        }
      }
    });
    return spans;
  };

  _proto.checkBrowserResponsiveness = function checkBrowserResponsiveness(transaction, interval, buffer) {
    var counter = transaction.browserResponsivenessCounter;
    var duration = transaction.duration();
    var expectedCount = Math.floor(duration / interval);
    return counter + buffer >= expectedCount;
  };

  return PerformanceMonitoring;
}();

export default PerformanceMonitoring;